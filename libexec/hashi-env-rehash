#!/usr/bin/env bash
set -euo pipefail

if [ -n "${HASHIENV_DEBUG:-}" ]; then
  set -x
fi

if [ "${1:-}" == "--complete" ]; then
  echo --complete
  exit
fi

SHIM_PATH="${HASHIENV_ROOT}/shims"
# a semaphore to prevent concurrency problems
PROTOTYPE_SHIM_PATH="${SHIM_PATH}/.hashi-env-shim"

acquire_lock() {
  # Ensure only one instance of hashi-env-rehash is running at a time by
  # setting the shell's `noclobber` option and attempting to write to
  # the prototype shim file. If the file already exists, print a warning
  # to stderr and exit with a non-zero status.
  set -o noclobber
  if echo > "$PROTOTYPE_SHIM_PATH" 2>| /dev/null; then
    set +o noclobber
    return 0
  else
    set +o noclobber
    return 1
  fi
}

# If we were able to obtain a lock, register a trap to clean up the
# prototype shim when the process exits.
trap release_lock EXIT

remove_prototype_shim() {
  rm -f "$PROTOTYPE_SHIM_PATH"
}

release_lock() {
  remove_prototype_shim
}

if [ ! -w "$SHIM_PATH" ]; then
  log-error "cannot rehash: $SHIM_PATH isn't writable"
  exit 1
fi

unset acquired
for (( i=1; i<="${HASHIENV_REHASH_TIMEOUT:-60}"; i++ )); do
  if acquire_lock 2>/dev/null; then
    acquired=1
    break
  else
    # POSIX sleep(1) doesn't provides time precision of subsecond
    sleep 1
  fi
done

if [ -z "${acquired}" ]; then
  log-error "cannot rehash: $PROTOTYPE_SHIM_PATH exists"
  exit 1
fi

create_prototype_shim() {
  cat > "$PROTOTYPE_SHIM_PATH" <<SH
#!/usr/bin/env bash
set -euo pipefail

exec "$(command -v hashi-env)" exec "\${0##*/}" "\$@"
SH
  chmod +x "$PROTOTYPE_SHIM_PATH"
}

# If the contents of the prototype shim file differ from the contents
# of the first shim in the shims directory, assume hashi-env has been
# upgraded and the existing shims need to be removed.
remove_outdated_shims() {
  local shim
  for shim in "$SHIM_PATH"/*; do
    if ! diff "$PROTOTYPE_SHIM_PATH" "$shim" >/dev/null 2>&1; then
      rm -f "$SHIM_PATH"/*
    fi
    break
  done
}

# List basenames of every executable that is installed
list_executable_names() {
  local product
  list-products | \
  while read -r product; do
    if [ -z "$(list-versions "$(product-directory "$product")" "${product}-")" ]; then
      continue
    fi
    printf '%s\n' "$product"
  done
}

# The basename of each argument passed to `make_shims` will be
# registered for installation as a shim. In this way, plugins may call
# `make_shims` with a glob to register many shims at once.
make_shims() {
  local file shim
  for file; do
    shim="${file##*/}"
    register_shim "$shim"
  done
}

registered_shims=" "

# Registers the name of a shim to be generated.
register_shim() {
  registered_shims="${registered_shims}${1} "
}

# Install all the shims registered via `make_shims` or `register_shim` directly.
install_registered_shims() {
  local shim file
  for shim in $registered_shims; do
    file="${SHIM_PATH}/${shim}"
    [ -e "$file" ] || cp "$PROTOTYPE_SHIM_PATH" "$file"
  done
}

# Once the registered shims have been installed, we make a second pass
# over the contents of the shims directory. Any file that is present
# in the directory but has not been registered as a shim should be
# removed.
remove_stale_shims() {
  local shim
  for shim in "$SHIM_PATH"/*; do
    if [[ "$registered_shims" != *" ${shim##*/} "* ]]; then
      rm -f "$shim"
    fi
  done
}

shopt -s nullglob

# Create the prototype shim, then register shims for all known
# executables.
create_prototype_shim
remove_outdated_shims
# shellcheck disable=SC2046
make_shims $(list_executable_names | sort -u)


# Allow plugins to register shims.

# OLDIFS="$IFS"
# IFS=$'\n' scripts=(`hashi-env-hooks rehash`)
# IFS="$OLDIFS"

# for script in "${scripts[@]}"; do
#   source "$script"
# done

install_registered_shims
remove_stale_shims
